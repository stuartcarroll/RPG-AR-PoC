<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG AR Experience - Image Tracking</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #ffffff;
            color: #333333;
            overflow: hidden;
            margin: 0;
            line-height: 1.6;
        }

        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 40px 20px;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            min-height: 80vh;
        }

        .main-header {
            text-align: center;
            margin-bottom: 60px;
        }

        .main-header h1 {
            font-size: 3rem;
            font-weight: 300;
            margin: 0 0 16px 0;
            color: #2c2c2c;
            letter-spacing: -1px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #666666;
            font-weight: 400;
            margin: 0;
        }

        .artwork-grid {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 40px;
        }

        .artwork-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 48px 40px;
            text-align: center;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            max-width: 500px;
            width: 100%;
        }

        .artwork-card:hover {
            box-shadow: 0 8px 25px rgba(0,0,0,0.12);
            transform: translateY(-2px);
        }

        .artwork-info {
            margin-bottom: 32px;
        }

        .artwork-title {
            font-size: 1.8rem;
            font-weight: 500;
            margin: 0 0 16px 0;
            color: #2c2c2c;
        }

        .artwork-description {
            font-size: 1rem;
            color: #666666;
            margin: 0;
            line-height: 1.5;
        }

        .experience-button {
            background: #2c2c2c;
            border: none;
            color: white;
            padding: 16px 32px;
            font-size: 1rem;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .experience-button:hover {
            background: #1a1a1a;
            transform: translateY(-1px);
        }

        .button-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .experience-button:hover .button-icon {
            transform: translateX(4px);
        }

        .page-footer {
            text-align: center;
            padding: 20px 0;
            border-top: 1px solid #e0e0e0;
        }

        .page-footer p {
            font-size: 0.9rem;
            color: #999999;
            margin: 0;
        }

        @media (max-width: 768px) {
            .main-header h1 {
                font-size: 2.2rem;
            }

            .subtitle {
                font-size: 1.1rem;
            }

            .artwork-card {
                padding: 32px 24px;
                margin: 0 16px;
            }

            .artwork-title {
                font-size: 1.5rem;
            }

            .container {
                padding: 20px;
            }
        }

        #ar-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
        }

        #video-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #ar-content {
            position: absolute;
            display: none;
            transition: all 0.3s ease-out;
            transform-origin: center center;
        }

        #ar-video {
            width: 250px;
            height: 180px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            background: rgba(0, 0, 0, 0.1);
            object-fit: cover;
        }

        #detection-box {
            display: none !important;
        }

        #status {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            color: #333;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            text-align: center;
            backdrop-filter: blur(10px);
            font-weight: 500;
        }

        #confidence, #position, #fps {
            display: none;
        }

        #debug-canvas {
            display: none;
        }

        #target-img {
            display: none;
        }

        .detected { color: #00ff00; }
        .tracking { color: #00aaff; }
        .searching { color: #ffaa00; }
        .error { color: #ff0000; }

        #controls {
            display: none;
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <div class="container">
            <header class="main-header">
                <h1>RPG AR Experience</h1>
                <p class="subtitle">Interactive Artwork Recognition</p>
            </header>
            
            <main class="artwork-grid">
                <div class="artwork-card">
                    <div class="artwork-info">
                        <h2 class="artwork-title">The Adoration of the Saints</h2>
                        <p class="artwork-description">Point your camera at the painting to begin the AR experience</p>
                    </div>
                    <button id="start-button" class="experience-button">
                        <span class="button-text">Start Experience</span>
                        <span class="button-icon">â†’</span>
                    </button>
                </div>
            </main>
            
            <footer class="page-footer">
                <p>Powered by Computer Vision & AR Technology</p>
            </footer>
        </div>
    </div>

    <div id="ar-container">
        <video id="video-feed" autoplay playsinline muted></video>
        
        <div id="ar-overlay">
            <div id="detection-box"></div>
            <div id="ar-content">
                <video id="ar-video" loop muted playsinline preload="auto">
                    <source src="vid1.mp4" type="video/mp4">
                </video>
            </div>
        </div>

        <canvas id="debug-canvas"></canvas>

        <div id="status" class="searching">
            <div id="status-text">Initializing camera...</div>
            <div id="confidence">Confidence: 0%</div>
            <div id="position">Position: -</div>
            <div id="fps">FPS: -</div>
        </div>
        
        <div id="controls">
            <button id="test-button">Test Detection</button>
        </div>

        <img id="target-img" src="paint1.jpg" alt="Target">
    </div>

    <script>
        class ImageTracker {
            constructor() {
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.debugCanvas = null;
                this.debugCtx = null;
                this.arVideo = null;
                this.arContent = null;
                this.detectionBox = null;
                
                this.isTracking = false;
                this.targetImage = null;
                this.lastDetection = null;
                this.detectionHistory = [];
                this.smoothingFactor = 0.9;
                this.consecutiveDetections = 0;
                this.requiredConsecutive = 3; // Need 3 consecutive good detections
                
                // Performance tracking
                this.frameCount = 0;
                this.lastFpsTime = Date.now();
                
                // Detection parameters
                this.confidenceThreshold = 0.6; // Very high threshold - only trigger on very good matches
                this.skipFrames = 3; // Process every 4th frame for stability
                this.currentFrame = 0;
                
                this.init();
            }

            init() {
                document.getElementById('start-button').addEventListener('click', () => {
                    this.startAR();
                });
                
                document.getElementById('test-button').addEventListener('click', () => {
                    this.testDetection();
                });
                
                this.arContent = document.getElementById('ar-content');
                this.arVideo = document.getElementById('ar-video');
                this.detectionBox = document.getElementById('detection-box');
            }

            async startAR() {
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('ar-container').style.display = 'block';

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            facingMode: 'environment',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });

                    this.video = document.getElementById('video-feed');
                    this.video.srcObject = stream;
                    
                    // Setup processing canvas
                    this.canvas = document.createElement('canvas');
                    this.ctx = this.canvas.getContext('2d');
                    
                    // Setup debug canvas
                    this.debugCanvas = document.getElementById('debug-canvas');
                    this.debugCtx = this.debugCanvas.getContext('2d');

                    this.video.onloadedmetadata = () => {
                        this.canvas.width = 320;
                        this.canvas.height = 240;
                        
                        this.debugCanvas.width = 160;
                        this.debugCanvas.height = 120;
                        
                        this.loadTargetImage();
                    };

                } catch (error) {
                    this.updateStatus('Camera access denied', 'error');
                    console.error('Camera error:', error);
                }
            }

            loadTargetImage() {
                this.updateStatus('Loading target image...', 'searching');
                
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    // Create standardized target
                    const targetCanvas = document.createElement('canvas');
                    const targetCtx = targetCanvas.getContext('2d');
                    targetCanvas.width = 80;
                    targetCanvas.height = 60;
                    targetCtx.drawImage(img, 0, 0, 80, 60);
                    
                    this.targetImage = targetCtx.getImageData(0, 0, 80, 60);
                    this.updateStatus('Ready! Point camera at painting', 'searching');
                    this.startTracking();
                };
                img.src = 'paint1.jpg';
            }

            startTracking() {
                this.isTracking = true;
                this.trackingLoop();
            }

            trackingLoop() {
                if (!this.isTracking) return;

                this.currentFrame++;
                if (this.currentFrame % (this.skipFrames + 1) !== 0) {
                    requestAnimationFrame(() => this.trackingLoop());
                    return;
                }

                try {
                    // Draw video to processing canvas
                    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                    
                    // Show debug view
                    this.debugCtx.drawImage(this.canvas, 0, 0, this.debugCanvas.width, this.debugCanvas.height);
                    
                    const frameData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Detect image
                    const detection = this.detectImage(frameData);
                    
                    // Smooth detection
                    this.updateDetectionHistory(detection);
                    
                    const avgDetection = this.getSmoothedDetection();
                    
                    if (avgDetection.confidence > this.confidenceThreshold) {
                        this.consecutiveDetections++;
                        if (this.consecutiveDetections >= this.requiredConsecutive) {
                            this.onImageDetected(avgDetection);
                        }
                    } else {
                        this.consecutiveDetections = 0;
                        this.onImageLost();
                    }
                    
                    this.updateFPS();
                    this.updateDebugInfo(avgDetection);
                    
                } catch (error) {
                    console.error('Tracking error:', error);
                }

                requestAnimationFrame(() => this.trackingLoop());
            }

            detectImage(frameData) {
                let bestMatch = { confidence: 0, x: 0, y: 0, scale: 1 };
                
                // Multi-scale detection
                const scales = [0.6, 0.8, 1.0, 1.2, 1.4];
                
                for (const scale of scales) {
                    const match = this.templateMatch(frameData, scale);
                    
                    // Require minimum size to avoid tiny false positives
                    const minScreenSize = 100; // pixels
                    const screenW = (match.width || 80) * (window.innerWidth / this.canvas.width);
                    const screenH = (match.height || 60) * (window.innerHeight / this.canvas.height);
                    
                    if (match.confidence > bestMatch.confidence && 
                        screenW > minScreenSize && 
                        screenH > minScreenSize) {
                        bestMatch = { ...match, scale };
                    }
                }
                
                return bestMatch;
            }

            templateMatch(frameData, scale) {
                const targetW = Math.floor(80 * scale);
                const targetH = Math.floor(60 * scale);
                const step = Math.max(4, Math.floor(8 / scale));
                
                let bestScore = 0;
                let bestX = 0;
                let bestY = 0;
                
                for (let y = 0; y <= frameData.height - targetH; y += step) {
                    for (let x = 0; x <= frameData.width - targetW; x += step) {
                        const score = this.calculateMatch(frameData, x, y, targetW, targetH);
                        if (score > bestScore) {
                            bestScore = score;
                            bestX = x;
                            bestY = y;
                        }
                    }
                }
                
                return {
                    confidence: bestScore,
                    x: bestX,
                    y: bestY,
                    width: targetW,
                    height: targetH
                };
            }

            calculateMatch(frameData, startX, startY, width, height) {
                let score = 0;
                let samples = 0;
                const step = 2; // Finer sampling for better accuracy
                let colorVariance = 0;
                let edgeScore = 0;
                
                for (let y = 0; y < height; y += step) {
                    for (let x = 0; x < width; x += step) {
                        const frameX = startX + x;
                        const frameY = startY + y;
                        
                        if (frameX < frameData.width && frameY < frameData.height) {
                            const frameIdx = (frameY * frameData.width + frameX) * 4;
                            
                            const targetX = Math.floor((x / width) * 80);
                            const targetY = Math.floor((y / height) * 60);
                            const targetIdx = (targetY * 80 + targetX) * 4;
                            
                            if (targetIdx < this.targetImage.data.length) {
                                // Enhanced RGB comparison with weighted channels
                                let diff = 0;
                                const frameR = frameData.data[frameIdx];
                                const frameG = frameData.data[frameIdx + 1];
                                const frameB = frameData.data[frameIdx + 2];
                                const targetR = this.targetImage.data[targetIdx];
                                const targetG = this.targetImage.data[targetIdx + 1];
                                const targetB = this.targetImage.data[targetIdx + 2];
                                
                                // Weighted RGB difference (human eye sensitivity)
                                diff = Math.abs(frameR - targetR) * 0.3 + 
                                       Math.abs(frameG - targetG) * 0.59 + 
                                       Math.abs(frameB - targetB) * 0.11;
                                
                                const pixelScore = Math.max(0, 255 - diff) / 255;
                                score += pixelScore;
                                
                                // Track color variance for uniqueness
                                const intensity = (frameR + frameG + frameB) / 3;
                                colorVariance += Math.abs(intensity - 128); // Distance from gray
                                
                                samples++;
                            }
                        }
                    }
                }
                
                if (samples === 0) return 0;
                
                const baseScore = score / samples;
                const varianceBonus = Math.min(0.3, colorVariance / (samples * 100)); // Bonus for colorful images
                
                return Math.min(1, baseScore + varianceBonus);
            }

            updateDetectionHistory(detection) {
                this.detectionHistory.push(detection);
                if (this.detectionHistory.length > 8) {
                    this.detectionHistory.shift();
                }
            }

            getSmoothedDetection() {
                if (this.detectionHistory.length === 0) return { confidence: 0, x: 0, y: 0 };
                
                let totalConfidence = 0;
                let totalX = 0;
                let totalY = 0;
                let totalScale = 0;
                let count = 0;
                
                // Weighted average, giving more weight to recent detections
                for (let i = 0; i < this.detectionHistory.length; i++) {
                    const weight = (i + 1) / this.detectionHistory.length; // More recent = higher weight
                    const detection = this.detectionHistory[i];
                    
                    totalConfidence += detection.confidence * weight;
                    totalX += detection.x * weight;
                    totalY += detection.y * weight;
                    totalScale += (detection.scale || 1) * weight;
                    count += weight;
                }
                
                return {
                    confidence: totalConfidence / count,
                    x: totalX / count,
                    y: totalY / count,
                    scale: totalScale / count,
                    width: this.detectionHistory[this.detectionHistory.length - 1].width,
                    height: this.detectionHistory[this.detectionHistory.length - 1].height
                };
            }

            onImageDetected(detection) {
                this.updateStatus('ðŸŽ¯ Tracking painting...', 'tracking');
                this.lastDetection = Date.now();
                
                // Convert canvas coordinates to screen coordinates
                const scaleX = window.innerWidth / this.canvas.width;
                const scaleY = window.innerHeight / this.canvas.height;
                
                const screenX = detection.x * scaleX;
                const screenY = detection.y * scaleY;
                const screenW = detection.width * scaleX;
                const screenH = detection.height * scaleY;
                
                // Position AR content directly over the detected image
                const centerX = screenX + screenW / 2;
                const centerY = screenY + screenH / 2;
                
                // Place video at the same location as detection
                this.arContent.style.left = screenX + 'px';
                this.arContent.style.top = screenY + 'px';
                this.arContent.style.display = 'block';
                
                // Scale video to match detected image size
                const videoWidth = Math.max(200, screenW);
                const videoHeight = Math.max(150, screenH);
                this.arVideo.style.width = videoWidth + 'px';
                this.arVideo.style.height = videoHeight + 'px';
                
                // Detection box removed - cleaner UI
                
                // Play video
                if (this.arVideo.paused) {
                    this.arVideo.play().catch(e => console.log('Video play failed:', e));
                }
            }

            onImageLost() {
                if (Date.now() - (this.lastDetection || 0) > 2000) { // 2 second grace period for stability
                    this.updateStatus('ðŸ“± Searching for painting...', 'searching');
                    
                    this.arContent.style.display = 'none';
                    
                    if (!this.arVideo.paused) {
                        this.arVideo.pause();
                    }
                }
            }

            testDetection() {
                // Simulate detection in center of screen
                const mockDetection = {
                    confidence: 0.8,
                    x: this.canvas.width / 2 - 40,
                    y: this.canvas.height / 2 - 30,
                    width: 80,
                    height: 60,
                    scale: 1.0
                };
                
                this.detectionHistory = [mockDetection];
                this.onImageDetected(mockDetection);
                
                // Auto-hide after 8 seconds
                setTimeout(() => {
                    this.lastDetection = 0;
                    this.onImageLost();
                }, 8000);
            }

            updateStatus(message, type) {
                document.getElementById('status-text').textContent = message;
                document.getElementById('status').className = type;
            }

            updateDebugInfo(detection) {
                document.getElementById('confidence').textContent = 
                    `Confidence: ${Math.round(detection.confidence * 100)}%`;
                document.getElementById('position').textContent = 
                    `Position: ${Math.round(detection.x)}, ${Math.round(detection.y)}`;
            }

            updateFPS() {
                this.frameCount++;
                const now = Date.now();
                if (now - this.lastFpsTime >= 1000) {
                    const fps = Math.round(this.frameCount * 1000 / (now - this.lastFpsTime));
                    document.getElementById('fps').textContent = `FPS: ${fps}`;
                    this.frameCount = 0;
                    this.lastFpsTime = now;
                }
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            new ImageTracker();
        });
    </script>
</body>
</html>